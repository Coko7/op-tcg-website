import fs from 'fs';
import path from 'path';
import crypto from 'crypto';
import { Database } from '../utils/database.js';
import { CardModel } from '../models/Card.js';
import { BoosterModel } from '../models/Booster.js';
export class CardUpdateService {
    vegapullDataPath;
    vegapullImagesPath;
    constructor() {
        this.vegapullDataPath = process.env.VEGAPULL_DATA_PATH || '../public/data/vegapull';
        this.vegapullImagesPath = process.env.VEGAPULL_IMAGES_PATH || '../public/images/cards';
    }
    /**
     * Met √† jour toutes les cartes et boosters depuis les donn√©es Vegapull
     */
    async updateFromVegapull(forceUpdate = false) {
        console.log('üîÑ D√©but de la mise √† jour depuis Vegapull...');
        const result = {
            success: false,
            cardsAdded: 0,
            cardsUpdated: 0,
            boostersAdded: 0,
            boostersUpdated: 0,
            errors: []
        };
        try {
            // V√©rifier si une mise √† jour est n√©cessaire
            if (!forceUpdate) {
                const needsUpdate = await this.checkIfUpdateNeeded();
                if (!needsUpdate) {
                    console.log('‚ÑπÔ∏è Aucune mise √† jour n√©cessaire');
                    result.success = true;
                    return result;
                }
            }
            // Backup avant mise √† jour
            const backupPath = await Database.backup(`cards_update_backup_${Date.now()}.sqlite`);
            console.log(`üõ°Ô∏è Backup cr√©√©: ${backupPath}`);
            await Database.transaction(async () => {
                // 1. Mettre √† jour les boosters
                console.log('üì¶ Mise √† jour des boosters...');
                const boosterResult = await this.updateBoosters();
                result.boostersAdded = boosterResult.added;
                result.boostersUpdated = boosterResult.updated;
                // 2. Mettre √† jour les cartes
                console.log('üÉè Mise √† jour des cartes...');
                const cardResult = await this.updateCards();
                result.cardsAdded = cardResult.added;
                result.cardsUpdated = cardResult.updated;
                // 3. Enregistrer la mise √† jour
                await this.recordUpdate(result);
            });
            result.success = true;
            console.log('‚úÖ Mise √† jour termin√©e avec succ√®s');
        }
        catch (error) {
            const errorMsg = error instanceof Error ? error.message : 'Erreur inconnue';
            result.errors.push(errorMsg);
            console.error('‚ùå Erreur lors de la mise √† jour:', error);
        }
        return result;
    }
    /**
     * V√©rifie si une mise √† jour est n√©cessaire en comparant les hash
     */
    async checkIfUpdateNeeded() {
        try {
            const currentHash = await this.calculateVegapullDataHash();
            const lastUpdate = await Database.get(`
        SELECT vegapull_data_hash
        FROM card_updates
        ORDER BY applied_at DESC
        LIMIT 1
      `);
            if (!lastUpdate || lastUpdate.vegapull_data_hash !== currentHash) {
                console.log('üîç Changements d√©tect√©s dans les donn√©es Vegapull');
                return true;
            }
            return false;
        }
        catch (error) {
            console.log('‚ö†Ô∏è Impossible de v√©rifier les changements, for√ßage de la mise √† jour');
            return true;
        }
    }
    /**
     * Met √† jour les boosters depuis les donn√©es Vegapull
     */
    async updateBoosters() {
        const packsPath = path.join(this.vegapullDataPath, 'packs.json');
        if (!fs.existsSync(packsPath)) {
            throw new Error('Fichier packs.json non trouv√©');
        }
        const packsData = JSON.parse(fs.readFileSync(packsPath, 'utf8'));
        let added = 0;
        let updated = 0;
        for (const pack of packsData) {
            const boosterData = {
                id: pack.id,
                name: pack.title_parts.title,
                code: pack.title_parts.label || pack.id.toUpperCase(),
                series: pack.title_parts.prefix || 'BOOSTER PACK',
                description: `Booster pack ${pack.title_parts.title} de la s√©rie ${pack.title_parts.prefix || 'One Piece TCG'}`,
                release_date: '2022-07-08', // Date par d√©faut, peut √™tre mise √† jour plus tard
                card_count: 121, // Valeur par d√©faut
                image_url: `/boosters/${pack.id.toLowerCase()}.jpg`
            };
            const result = await BoosterModel.upsert(boosterData);
            if (result.wasCreated) {
                added++;
            }
            else if (result.wasUpdated) {
                updated++;
            }
        }
        console.log(`üì¶ Boosters: ${added} ajout√©s, ${updated} mis √† jour`);
        return { added, updated };
    }
    /**
     * Met √† jour les cartes depuis les donn√©es Vegapull
     */
    async updateCards() {
        const allCards = [];
        // Lire toutes les cartes depuis les fichiers de packs
        const packsDir = this.vegapullDataPath;
        const packFiles = fs.readdirSync(packsDir)
            .filter(file => file.startsWith('pack_') && file.endsWith('.json'));
        for (const packFile of packFiles) {
            try {
                const packPath = path.join(packsDir, packFile);
                const packData = JSON.parse(fs.readFileSync(packPath, 'utf8'));
                if (packData.cards && Array.isArray(packData.cards)) {
                    allCards.push(...packData.cards.map((card) => ({
                        ...card,
                        character: card.character || card.character_name || card.name,
                        booster_id: packData.id || packFile.replace('pack_', '').replace('.json', '')
                    })));
                }
            }
            catch (error) {
                console.warn(`‚ö†Ô∏è Erreur lors de la lecture du pack ${packFile}:`, error);
            }
        }
        console.log(`üìä ${allCards.length} cartes trouv√©es dans les donn√©es Vegapull`);
        // Convertir et traiter les cartes par batch
        const BATCH_SIZE = 100;
        let totalAdded = 0;
        let totalUpdated = 0;
        for (let i = 0; i < allCards.length; i += BATCH_SIZE) {
            const batch = allCards.slice(i, i + BATCH_SIZE);
            const cardData = batch.map(card => this.convertVegapullCard(card));
            const result = await CardModel.batchUpsert(cardData);
            totalAdded += result.created;
            totalUpdated += result.updated;
            // Progress log
            const progress = Math.min(i + BATCH_SIZE, allCards.length);
            console.log(`üìà Progression: ${progress}/${allCards.length} cartes trait√©es`);
        }
        // D√©tecter les cartes supprim√©es (pr√©sentes en DB mais plus dans Vegapull)
        await this.handleRemovedCards(allCards);
        console.log(`üÉè Cartes: ${totalAdded} ajout√©es, ${totalUpdated} mises √† jour`);
        return { added: totalAdded, updated: totalUpdated };
    }
    /**
     * Convertit une carte Vegapull vers notre format
     */
    convertVegapullCard(vegapullCard) {
        // Mapper les raret√©s si n√©cessaire
        const rarityMapping = {
            'C': 'common',
            'UC': 'uncommon',
            'R': 'rare',
            'SR': 'super_rare',
            'SEC': 'secret_rare',
            'L': 'rare' // Leaders trait√©s comme rare
        };
        return {
            id: vegapullCard.id,
            name: vegapullCard.name,
            character_name: vegapullCard.character,
            rarity: rarityMapping[vegapullCard.rarity] || vegapullCard.rarity.toLowerCase(),
            attack: vegapullCard.attack,
            defense: vegapullCard.defense,
            cost: vegapullCard.cost,
            power: vegapullCard.power,
            counter: vegapullCard.counter,
            color: vegapullCard.color,
            type: vegapullCard.type,
            description: vegapullCard.description || '',
            special_ability: vegapullCard.special_ability,
            image_url: vegapullCard.image_url || this.generateImageUrl(vegapullCard.id),
            booster_id: vegapullCard.booster_id
        };
    }
    /**
     * G√©n√®re une URL d'image pour une carte
     */
    generateImageUrl(cardId) {
        return `/images/cards/${cardId.toLowerCase()}.jpg`;
    }
    /**
     * G√®re les cartes supprim√©es (plus pr√©sentes dans Vegapull)
     */
    async handleRemovedCards(vegapullCards) {
        const vegapullIds = new Set(vegapullCards.map(card => card.id));
        const dbCards = await CardModel.findAll(999999); // R√©cup√©rer toutes les cartes
        const removedCards = dbCards.filter(card => !vegapullIds.has(card.id));
        if (removedCards.length > 0) {
            console.log(`‚ö†Ô∏è ${removedCards.length} cartes supprim√©es d√©tect√©es`);
            // Backup des cartes supprim√©es avant d√©sactivation
            for (const card of removedCards) {
                await Database.run(`
          INSERT INTO missing_cards_backup (id, card_id, card_data, removal_reason)
          VALUES (?, ?, ?, ?)
        `, [
                    crypto.randomUUID(),
                    card.id,
                    JSON.stringify(card),
                    'Removed from Vegapull data'
                ]);
                await CardModel.deactivate(card.id);
            }
            console.log(`üóÑÔ∏è ${removedCards.length} cartes d√©sactiv√©es et sauvegard√©es`);
        }
    }
    /**
     * Calcule le hash des donn√©es Vegapull pour d√©tecter les changements
     */
    async calculateVegapullDataHash() {
        const hash = crypto.createHash('md5');
        // Hash du fichier packs.json
        const packsPath = path.join(this.vegapullDataPath, 'packs.json');
        if (fs.existsSync(packsPath)) {
            const packsData = fs.readFileSync(packsPath);
            hash.update(packsData);
        }
        // Hash des fichiers de packs individuels
        const packFiles = fs.readdirSync(this.vegapullDataPath)
            .filter(file => file.startsWith('pack_') && file.endsWith('.json'))
            .sort(); // Trier pour un hash coh√©rent
        for (const packFile of packFiles) {
            const packPath = path.join(this.vegapullDataPath, packFile);
            const packData = fs.readFileSync(packPath);
            hash.update(packData);
        }
        return hash.digest('hex');
    }
    /**
     * Enregistre la mise √† jour dans la base de donn√©es
     */
    async recordUpdate(result) {
        const updateHash = await this.calculateVegapullDataHash();
        await Database.run(`
      INSERT INTO card_updates (
        id, update_version, update_type, cards_added, cards_updated,
        boosters_added, boosters_updated, vegapull_data_hash, applied_by
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
    `, [
            crypto.randomUUID(),
            new Date().toISOString(),
            'both',
            result.cardsAdded,
            result.cardsUpdated,
            result.boostersAdded,
            result.boostersUpdated,
            updateHash,
            'system'
        ]);
    }
    /**
     * R√©cup√®re l'historique des mises √† jour
     */
    async getUpdateHistory(limit = 10) {
        return await Database.all(`
      SELECT *
      FROM card_updates
      ORDER BY applied_at DESC
      LIMIT ?
    `, [limit]);
    }
    /**
     * Restaure des cartes depuis le backup
     */
    async restoreRemovedCards(cardIds) {
        let restored = 0;
        await Database.transaction(async () => {
            for (const cardId of cardIds) {
                const backup = await Database.get(`
          SELECT card_data
          FROM missing_cards_backup
          WHERE card_id = ?
          ORDER BY removed_at DESC
          LIMIT 1
        `, [cardId]);
                if (backup) {
                    const cardData = JSON.parse(backup.card_data);
                    await CardModel.upsert(cardData);
                    restored++;
                }
            }
        });
        console.log(`üîÑ ${restored} cartes restaur√©es depuis le backup`);
        return restored;
    }
}
//# sourceMappingURL=CardUpdateService.js.map